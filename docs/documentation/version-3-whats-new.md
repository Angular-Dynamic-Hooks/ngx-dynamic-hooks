---
---

# Version 3 - What's new?

![angular_dynamic_hooks_v3](https://github.com/user-attachments/assets/21377754-7f2e-4d54-92bd-e23ba45dbf39)

Version 3 marks a significant overhaul and modernization of the Angular Dynamic Hooks library. It is now fully up-to-date with **Angular 17+**, easier to use and has several completely new features.

**The good news**: Users of version 2 should only minimally need to adjust their code for the upgrade to version 3. Nevertheless, there are some breaking changes to look out for (see below)

## New features

### Standalone components

The whole library was converted to the more modern standalone component structure. As such, there is no more `DynamicHooksModule`.

Instead, you can now use `provideDynamicHooks()` to register the global settings in your app's root providers and import the `DynamicHooksComponent` (`<ngx-dynamic-hooks>`) in the components/modules [where you need it]({{ "documentation/quickstart" | relative_url }})).

### Less boilerplate

With version 3, configuring global settings/providers has become optional. So you don't need to use `provideDynamicHooks` at all. You can directly import the `DynamicHooksComponent` and start using the library.

In addition, you can now simply use the component classes themselves to set up a standard parser for them (see the [Quickstart example]({{ "documentation/quickstart" | relative_url }})).

**Tip:** You can do the same thing with `provideDynamicHooks`. Just give it an array of component classes like `provideDynamicHooks([MyComponent])` and the library will globally look for `MyComponent` in any submitted content.

### SSR-Compatibility

The core functionality of the library has been adjusted to work with Server-Side-Rendering under Angular 17+ out of the box. You can however still [implement your own PlatformService]({{ "documentation/configuration#alternative-platforms" | relative_url }}), if you have a more specific use-case.

### New: HTML as content

Previously, you could only pass strings as the `content` input to the library. With v3, you can now also submit HTML elements directly - even `document.body`! The library will look through all its child elements, search for hooks/selectors and automatically load components for them.

### New: Element hooks

Related to that, you can now look for **element hooks** in addition to **text hooks**. Element hooks find and load components into HTML elements (instead of replacing text patterns), so custom parsers can use [simple browser methods]({{ "documentation/parsers#findhookelements" | relative_url }}) to find them (`querySelectorAll`, etc.).

The standard `SelectorHookParser` now also uses the new element hooks under the mood. This has the benefit that it is now able to use proper CSS selectors (`.myComponent`) for finding hooks instead of just tag names like before.

### New: Standalone mode

With the new [standalone mode]({{ "documentation/standalone-mode" | relative_url }}), you can use the library **outside of an Angular app**. This means, you can load fully-functional Angular components in non-Angular contexts - for example to add "Angular widgets" to HTML generated by a CMS, static page generators, etc.

### New: Single component

In case you just need to load a single dynamic component in your template, a new [DynamicSingleComponent]( {{ "documentation/single-component" | relative_url }}) was added to make this process as easy as possible.

## Breaking changes

### DynamicHooksModule

As the library has fully transitioned to standalone components, you can no longer call `DynamicHooksModule.forRoot()` in your own module/providers. 

The replacement is called `provideDynamicHooks()` and you can put it in the `providers` array of your app configuration or module. It accepts the same arguments that `forRoot()` previously did. Note that `provideDynamicHooks()` itself is now completely optional.

The only thing required to use the library now is to put the `DynamicHooksComponent` into the `imports` field of your module/component. You can then use `<ngx-dynamic-hooks>` in your templates as usual.

### Child modules

If you were previously using `DynamicHooksModule.forChild()`, you can now simply call `provideDynamicHooks()` again in your child providers to register the child settings. You can do this as deeply nested as you want.

Also, note that `DynamicHooksInheritance.LINEAR` is now the default option (instead of `ALL`) as its more in line with angular's default behaviour.

### Renamings

Several classes, interfaces, methods etc. were renamed to better reflect their new roles.

- `DynamicHooksGlobalSettings` and its properties `globalParsers`, `globalOptions`, `lazyInheritance` are now just `DynamicHooksSettings`, `parsers`, `options` and `inheritance`
- `OutletComponent` is now `DynamicHooksComponent`
- `OutletService` is now `DynamicHooksService`. Also, the order of the parameters for the `parse` method [has changed]({{ "documentation/how-to-use#programmatic-usage-with-service" | relative_url }}).
- `OutletParseResult` is now `ParseResult` and returns more properties
- `OutletOptions` is now `ParseOptions`
- `HookFinder.findStandaloneHooks` is now `HookFinder.findSingletagHooks`. You can now also just use `HookFinder.find` for both singletag or enclosing hooks.

## Minor changes

- Traditional text hook parsers from version 2 remain mostly unchanged - with one exception: They will now use `<dynamic-component-anchor>`-elements for components by default. If you want to continue using the component selector, you must specify it manually via the [`hostElementTag` property]({{ "documentation/parsers#loadcomponent" | relative_url }}).
- `DynamicContentChild.componentSelector` field has been removed. you can mostly accomplish the same via `DynamicContentChild.componentRef.location.nativeElement.tagName`.